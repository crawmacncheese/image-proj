# -*- coding: utf-8 -*-
"""AMSNet_1.1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15eQcvva9l6O5cc2GWt9Qux8xNoyrUBCQ

# Setup
"""
from flask import Flask, request;

import cmath
import codecs
import glob
import json
import os
import matplotlib.pyplot as plt
import numpy as np
import cv2
import numpy as np
from matplotlib import pyplot as plt
# from google.colab.patches import cv2_imshow

from PIL import Image, ImageDraw, ImageFont
from collections import defaultdict
from scipy.signal import convolve2d

# root_path = '/content/drive/MyDrive/2024/AMSNet/1.1.0'
root_path = 'components'
page_bin_path = f'{root_path}/page_bin'
page_img_path = f'{root_path}/page_img'
page_data_path = f'{root_path}/page_data'
page_netlist_path = f'{root_path}/page_netlist'
part_bin_path = f'{root_path}/part_bin'
part_img_path = f'{root_path}/part_img'

for file_path in [
  page_bin_path,
  page_img_path,
  page_data_path,
  page_netlist_path,
  part_bin_path,
  part_img_path
]:
  os.makedirs(file_path, exist_ok=True)

# image representations:
# selection_img: PIL.Image format
# selection_arr: numpy.array format
# selection_bin: binary numpy.array format, 1 indicates white, 0 indicates black
def img2bin(selection_img):
  selection_arr = np.array(selection_img)
  h, w, _ = selection_arr.shape
  result = np.zeros((h, w), dtype=np.uint8)
  for r in range(h):
    for c in range(w):
      result[r][c] = 1 if min(selection_arr[r][c]) >= 128 else 0
  return result

def bin2img(selection_bin):
  h, w = selection_bin.shape
  selection_arr = np.zeros((h, w, 3), dtype=np.uint8)
  for r in range(h):
    for c in range(w):
      selection_arr[r][c] = [0, 0, 0] if selection_bin[r][c] == 0 else [255, 255, 255]
  return Image.fromarray(np.array(selection_arr))

def np_save(arr, fn):
  with open(fn, 'wb') as f:
    np.save(f, arr)

def write_strings(filename, strings):
  codecs.open(filename, "w", encoding='utf-8').writelines(f"{s}\n" for s in strings)

from natsort import natsorted

# page_fns = natsorted(glob.glob(
#     '/content/drive/MyDrive/2024/AIGC/book/analog_1/clean_circuits/*.png'))
# PUT UPLOADED IMAGE ROOT HERE
page_fns = natsorted(glob.glob(
    'components/testimg.png'))
for i, page_fn in enumerate(page_fns):
  print(f'{i} / {len(page_fns)}: {page_fn}')
  page_img = Image.open(page_fn)
  page_arr = np.array(page_img)[:,:,:3]
  page_img = Image.fromarray(page_arr)
  page_bin = img2bin(page_img)
  page_img.save(f'{page_img_path}/{i}.jpg')
  np_save(page_bin, f'{page_bin_path}/{i}.npy')

# from google.colab import drive
# drive.mount('/content/drive')

"""# Cache"""

# !rm $root_path/part_img/*
# !rm $root_path/part_bin/*

part_fns = set(glob.glob(f'{part_bin_path}/*.npy'))   
bin_cache = defaultdict(lambda: None)
img_cache = defaultdict(lambda: None)


"""# Component detection"""

arial_font = ImageFont.truetype("/content/drive/MyDrive/2024/AIGC/book/Arial.ttf", 20)

def mark_bound(img, bound, name, color=(255, 0, 0), dist=(-25, -25), solid=False):
  top, left, bottom, right = bound
  draw = ImageDraw.Draw(img)
  if solid:
    draw.rectangle((left, top, right, bottom), fill=color)
  else:
    draw.line((left, top, right, top), fill=color)
    draw.line((left, bottom, right, bottom), fill=color)
    draw.line((left, top, left, bottom), fill=color)
    draw.line((right, top, right, bottom), fill=color)
  draw.text((left-dist[1], top-dist[0]), name, fill=color, font=arial_font)
  return img

def mark_bounds(page, bounds, color=(255, 0, 0), visualize=True, dist=(-25, -25), solid=False):
  page_img = page
  if isinstance(page_img, np.ndarray):
    page_img = bin2img(page_img)
  for part_name in bounds:
    for bound in bounds[part_name]:
      page_img = mark_bound(page_img, bound, part_name, color=color, dist=dist, solid=solid)

  if visualize:
    plt.imshow(page_img)
    # plt.show()
  return page_img

def mark_name_bounds(page_bin, name_bounds):
  page_img = bin2img(page_bin)
  for part_name in name_bounds:
    page_img = mark_bound(page_img, name_bounds[part_name], part_name, dist=(25, 25))

  plt.imshow(page_img)
  # plt.show()
  return page_img

def cache_selection(selection_fn):
  if bin_cache[selection_fn] is None:
    bin_cache[selection_fn] = np.load(selection_fn)
  selection_bin = bin_cache[selection_fn]
  return selection_bin

def rotate_bin_clockwise_90(selection_bin, k):
  return np.rot90(selection_bin, k=k, axes=(1,0))

def crop_part(page_fn, top, left, bottom, right, rotate=True, save_fn=''):
  top, bottom, left, right = int(top), int(bottom), int(left), int(right)
  page_bin = cache_selection(page_fn)
  part_bin = page_bin[top:bottom, left:right]
  part_img = bin2img(part_bin)
  plt.imshow(part_img)
  # plt.show()
  if save_fn == '':
    return

  part_type, part_angle, part_instance = save_fn.split('_')
  part_angle, part_instance = int(part_angle), int(part_instance)
  part_angles = [part_angle]
  if rotate:
    part_angles = [(part_angle + 90 * i) % 360 for i in range(4)]

  part_bin_fns = [f'{part_bin_path}/{part_type}_{angle}_{part_instance}.jpg' for angle in part_angles]
  part_img_fns = [f'{part_img_path}/{part_type}_{angle}_{part_instance}.jpg' for angle in part_angles]
  part_bins = [rotate_bin_clockwise_90(part_bin, k) for k in range(len(part_angles))]
  part_imgs = [bin2img(bin) for bin in part_bins]

  for bin_fn, img_fn, bin, img in zip(part_bin_fns, part_img_fns, part_bins, part_imgs):
    img.save(img_fn)
    np.save(open(bin_fn, 'wb'), bin)
    part_fns.add(bin_fn)
    bin_cache[bin_fn] = bin

def part_match(page_bin, part_bin, tolerance=0.85):
  result = cv2.matchTemplate(page_bin, part_bin, cv2.TM_CCOEFF_NORMED)
  loc = np.where(result >= tolerance)
  matches = []
  h, w = part_bin.shape
  for pt in zip(*loc[::-1]):
    matches.append((pt[1], pt[0], pt[1] + h, pt[0] + w, result[pt[1]][pt[0]]))
      # cv2.rectangle(page_bin, pt, (pt[0] + w, pt[1] + h), (0, 0, 255), 2)
  # plt.imshow(bin2img(page_bin))
  # plt.show()
  return matches

def bound_tuple2list(bounds):
  for part_name in bounds:
    bounds[part_name] = [[int(coord) for coord in bound] for bound in bounds[part_name]]
  return bounds

def part_match_all(page_fn, visualize=True):
  page_bin = cache_selection(page_fn)
  bounds = {}
  for part_fn in sorted(list(part_fns)):
    part_bin = cache_selection(part_fn)
    tolerance=0.75
    if 'vdd' in part_fn:
      tolerance=0.85
    bounds[part_fn] = part_match(page_bin, part_bin, tolerance=tolerance)
  bounds = merge_bounds(bounds)
  if visualize:
    mark_bounds(page_bin, bounds)
  bounds = bound_tuple2list(bounds)
  page_num = page_fn.split('/')[-1].split('.')[0]
  json.dump(bounds, codecs.open(f'{page_data_path}/{page_num}.json', 'w', encoding='utf-8'), indent=2)
  return page_bin, bounds

def merge_bounds(bounds):
  def bound_intersect(bound1, bound2):
    t1, l1, b1, r1, d1 = bound1
    t2, l2, b2, r2, d2 = bound2
    ti, li, bi, ri = max(t1, t2), max(l1, l2), min(b1, b2), min(r1, r2)
    if ti >= bi or li >= ri:
      return None
    return bound1 if d1 > d2 else bound2

  new_bounds = {}
  for part_fn in bounds:
    part_name = '_'.join(part_fn.split('/')[-1].split('_')[:-1])
    if part_name not in new_bounds:
      new_bounds[part_name] = []
    new_bounds[part_name] += [tuple(bound) for bound in bounds[part_fn]]

  bounds, new_bounds = new_bounds, {}
  for part_name in bounds:
    new_part_bounds = set()
    for bound in bounds[part_name]:
      for part_bound in list(new_part_bounds):
        intersect = bound_intersect(bound, part_bound)
        if intersect is not None:
          new_part_bounds.remove(part_bound)
          bound = intersect

      replaced = False
      for other_part_name in new_bounds:
        if other_part_name == part_name:
          continue
        for other_part_bound in list(new_bounds[other_part_name]):
          if bound_intersect(bound, other_part_bound) is not None:
            if bound[-1] < other_part_bound[-1]:
              replaced = True
              break
            new_bounds[other_part_name].remove(other_part_bound)
        if replaced:
          break

      if not replaced:
        new_part_bounds.add(bound)
    new_bounds[part_name] = new_part_bounds

  for part_name in new_bounds:
    new_bounds[part_name] = sorted([tuple(bound[:4]) for bound in new_bounds[part_name]])

  return new_bounds

# for i in range(894):
#   part_match_all(f'{page_bin_path}/{i}.npy', visualize=True)

"""# Net detection"""

part_categories = {
  'capacitor': 'C',
  'gnd': 'G',
  'current': 'I',
  'inductor': 'L',
  'mos': 'M',
  'net': 'N',
  'resistor': 'R',
  'voltage': 'V',
  'vdd': 'VDD',
  'npn': 'Q',
  'pnp': 'Q',
  'subskt': 'X',
}

def reformat_name(part_name, part_counts):
  part_name_root = 'U'
  for part_category_substr in part_categories:
    if part_category_substr in part_name:
      part_name_root = part_categories[part_category_substr]
      break
  part_counts[part_name_root] += 1
  return f'{part_name_root}{part_counts[part_name_root]}'

def reformat_names(bounds):
  part_counts = defaultdict(int)
  bound_names, name_bounds, bound_orig_names = {}, {}, {}
  for part_name in bounds:
    for i, bound in enumerate(bounds[part_name]):
      bound = tuple(bound)
      short_part_name = reformat_name(part_name, part_counts)
      bound_names[bound] = short_part_name
      name_bounds[short_part_name] = bound
      bound_orig_names[bound] = part_name
  return part_counts, bound_names, name_bounds, bound_orig_names

# top is 0, degrees in counter clockwise
def calc_angle(bound, conn):
  top, left, bottom, right = bound
  r, c = conn
  center_r, center_c = (top + bottom) // 2, (left + right) // 2
  dr, dc = r - center_r, c - center_c
  polar = cmath.polar(dr + dc * 1j)
  return (cmath.pi + polar[1] * 100 // 1 / 100) / cmath.pi * 180 // 1

def get_conn_bfs(page_bin, trace, visited, bound_names, start_r, start_c, connected):
  h, w = page_bin.shape
  queue = [(start_r, start_c)]
  while len(queue) > 0:
    r, c = queue.pop(0)
    if r < 0 or r >= h or c < 0 or c >= w or visited[r, c] > 0 or page_bin[r, c] == 1:
      continue

    visited[r, c], trace[r, c], in_bound = 1, 1, False
    for bound in bound_names:
      top, left, bottom, right = bound
      if r > top and r < bottom and c > left and c < right:
        connected[bound], in_bound = (r, c), True
        break

    if not in_bound:
      queue.extend([(r + dr, c + dc) for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]])

def get_conn_bfs_wrapper(page_bin, visited, bound_names, r, c, conns):
  connected = {}
  trace = np.zeros(page_bin.shape)
  get_conn_bfs(page_bin, trace, visited, bound_names, r, c, connected)
  intersections = []
  if len(connected) == 2:
    b1, b2 = connected.keys()
    name1, name2 = bound_names[b1], bound_names[b2]
    angle1, angle2 = calc_angle(b1, connected[b1]), calc_angle(b2, connected[b2])
    if name1 == 'M13' or name2 == 'M13':
      print('connecting', name1, name2, angle1, angle2, connected[b1], connected[b2])
    if name1 not in conns:
      conns[name1] = {}
    if name2 not in conns:
      conns[name2] = {}
    conns[name1][angle1] = (name2, connected[b1], connected[b2])
    conns[name2][angle2] = (name1, connected[b2], connected[b1])
  if len(connected) > 2:
    kernel = np.ones((15, 15))
    density = convolve2d(trace, kernel)
    density = convolve2d(density, kernel)
    ir, ic = np.unravel_index(np.argmax(density), density.shape)
    intersections.append((ir - 20, ic - 20, ir + 5, ic + 5))
  return intersections

def get_conns(part_counts, bound_names, name_bounds, bound_orig_names):
  visited, conns = np.zeros(page_bin.shape, dtype=np.int32), {}
  intersections = []
  for bound in bound_names:
    top, left, bottom, right = bound
    for r in range(top, bottom + 1):
      intersections += get_conn_bfs_wrapper(page_bin, visited, bound_names, r, left, conns)
      intersections += get_conn_bfs_wrapper(page_bin, visited, bound_names, r, right, conns)
    for c in range(left, right + 1):
      intersections += get_conn_bfs_wrapper(page_bin, visited, bound_names, top, c, conns)
      intersections += get_conn_bfs_wrapper(page_bin, visited, bound_names, bottom, c, conns)
  if len(intersections) == 0:
    return conns
  for intersection in intersections:
    part_counts['N'] += 1
    new_conn_name = f'N{part_counts["N"]}'
    bound_names[intersection] = new_conn_name
    name_bounds[new_conn_name] = intersection
    bound_orig_names[intersection] = 'net-intersection_0_0'
  return get_conns(part_counts, bound_names, name_bounds, bound_orig_names)

def pmos_order(conn_angle):
  if conn_angle > 30 and conn_angle <= 150: return 1
  if conn_angle > 150 and conn_angle <= 270: return 0
  return 2

def nmos_order(conn_angle):
  if conn_angle > 30 and conn_angle <= 150: return 1
  if conn_angle > 150 and conn_angle <= 270: return 2
  return 0

def pmos_cross_order(conn_angle):
  if conn_angle > 30 and conn_angle <= 150: return 1
  if conn_angle > 150 and conn_angle <= 240: return 0
  if conn_angle > 240 and conn_angle <= 300: return 3
  return 2

def nmos_cross_order(conn_angle):
  if conn_angle > 30 and conn_angle <= 150: return 1
  if conn_angle > 150 and conn_angle <= 240: return 2
  if conn_angle > 240 and conn_angle <= 300: return 3
  return 0

def current_order(conn_angle):
  if conn_angle > 90 and conn_angle <= 270: return 1
  return 0

def voltage_order(conn_angle):
  if conn_angle > 90 and conn_angle <= 270: return 1
  return 0

def merge_order(conn_angles, order_func, page_bin, bound, part_counts, rotate_angle, mirror):
  max_order = max([order_func(i) for i in range(360)]) + 1
  result = [None for _ in range(max_order)]
  for angle in conn_angles:
    order = order_func(angle)
    if result[order] is not None:
      continue
    result[order] = conn_angles[angle]

  for order in range(max_order):
    if result[order] is None:
      part_counts['N'] += 1
      created_net_name = f'N{part_counts["N"]}'
      created_pos = create_pos(page_bin, bound, order_func, order, rotate_angle, mirror)
      print('created', created_net_name, created_pos, 'for', bound)
      result[order] = (created_net_name, created_pos, created_pos)
  return result

def create_pos(page_bin, bound, order_func, order, rotate_angle, mirror):
  top, left, bottom, right = bound
  pos_candidates = []
  for r in range(top, bottom):
    pos_candidates.append((r, left))
    pos_candidates.append((r, right))
  for c in range(left, right):
    pos_candidates.append((top, c))
    pos_candidates.append((bottom, c))
  for r, c in pos_candidates:
    if page_bin[r, c] == 1: continue
    angle = calc_angle(bound, (r, c))
    angle = rotate_mirror_angle(angle, rotate_angle, mirror)
    if order_func(angle) == order:
      return (r, c)
  raise Exception(f'create pos error {bound} {order} {rotate_angle} {mirror}')

part_conn_order = {
  'pmos': pmos_order,
  'nmos': nmos_order,
  'current': current_order,
  'voltage': voltage_order,
  'npn': nmos_order,
  'pnp': pmos_order,
}

part_conn_order_priority = {
  'pmos-cross': pmos_cross_order,
  'nmos-cross': nmos_cross_order,
  'pmos-mirror-cross': pmos_cross_order,
  'nmos-mirror-cross': nmos_cross_order,
  'pmos-four': pmos_cross_order,
  'nmos-four': nmos_cross_order,
  'pmos-four-mirror': pmos_cross_order,
  'nmos-four-mirror': nmos_cross_order,
  'pnp-cross': pmos_cross_order,
  'npn-cross': nmos_cross_order,
  'pnp-mirror-cross': pmos_cross_order,
  'npn-mirror-cross': nmos_cross_order,
}

def rotate_mirror_angle(angle, rotate, mirror):
  new_angle = angle + rotate
  if mirror:
    new_angle = 360 - new_angle
  return (new_angle + 720) % 360

def reorder_conns(page_bin, part_counts, bound_orig_names, name_bounds, conns):
  ordered_conns = {}
  for part_name in conns:
    angle_order = sorted([(angle, conns[part_name][angle]) for angle in conns[part_name]])
    conn_order = [conn_part_name for angle, conn_part_name in angle_order]
    orig_part_name = bound_orig_names[name_bounds[part_name]]
    part_type = orig_part_name.split('_')[0]
    order_func = None
    for ordered_part_type in part_conn_order:
      if ordered_part_type in part_type:
        order_func = part_conn_order[ordered_part_type]
    for ordered_part_type in part_conn_order_priority:
      if ordered_part_type in part_type:
        order_func = part_conn_order_priority[ordered_part_type]
    if order_func is not None:
      new_conn_angles = {}
      rotate_angle = int(orig_part_name.split('_')[1])
      mirror = 'mirror' in part_type
      for angle in conns[part_name]:
        new_angle = rotate_mirror_angle(angle, rotate_angle, mirror)
        new_conn_angles[new_angle] = conns[part_name][angle]
      conn_order = merge_order(new_conn_angles, order_func, page_bin, name_bounds[part_name], part_counts, rotate_angle, mirror)
    ordered_conns[part_name] = conn_order

  return ordered_conns

def reroute_conns(bound_orig_names, name_bounds, ordered_conns):
  updated = False
  for part_name in ordered_conns:
    orig_part_name = bound_orig_names[name_bounds[part_name]]
    if '-intersection' in orig_part_name: continue
    for i, conn_part in enumerate(ordered_conns[part_name]):
      conn_part_name = conn_part[0]
      if conn_part_name not in name_bounds:
        continue
      try:
        orig_conn_part_name = bound_orig_names[name_bounds[conn_part_name]]
        if '-intersection' in orig_conn_part_name:
          for j, other_conn_part in enumerate(ordered_conns[conn_part_name]):
            if conn_part[2] == other_conn_part[1]:
              print(conn_part_name, name_bounds[conn_part_name], part_name, name_bounds[part_name])
              print(ordered_conns[conn_part_name])
              replace_conn = ordered_conns[conn_part_name][(j + 2) % 4]
              ordered_conns[part_name][i] = (replace_conn[0], conn_part[1], replace_conn[2])
              updated = True
              break
        if '-cross' in orig_conn_part_name:
          other_conn_part = ordered_conns[conn_part_name][3]
          if conn_part[2] == other_conn_part[1]:
            replace_conn = ordered_conns[conn_part_name][1]
            ordered_conns[part_name][i] = (replace_conn[0], conn_part[1], replace_conn[2])
            updated = True
            break
        if 'current' in orig_conn_part_name and 'arrow' not in orig_conn_part_name:
          other_conn_part = ordered_conns[conn_part_name][1]
          for j, other_conn_part in enumerate(ordered_conns[conn_part_name]):
            if conn_part[2] == other_conn_part[1]:
              replace_conn = ordered_conns[conn_part_name][(j + 1) % 2]
              ordered_conns[part_name][i] = (replace_conn[0], conn_part[1], replace_conn[2])
              updated = True
              break
      except Exception as e:
        print('reroute failed', e)
  if updated:
    reroute_conns(bound_orig_names, name_bounds, ordered_conns)

def disconnect_component_conns(part_counts, ordered_conns):
  direct_conns = {}
  for part_name in ordered_conns:
    if 'N' in part_name or 'VDD' in part_name or 'G' in part_name: continue
    for i, conn in enumerate(ordered_conns[part_name]):
      if 'N' in conn[0] or 'VDD' in conn[0] or 'G' in conn[0]: continue
      cpnt_conn_pair = tuple(sorted([part_name, conn[0]]))
      if cpnt_conn_pair not in direct_conns:
        part_counts["N"] += 1
        new_net = f'N{part_counts["N"]}'
        direct_conns[cpnt_conn_pair] = new_net
      new_net = direct_conns[cpnt_conn_pair]
      ordered_conns[part_name][i] = (new_net, conn[1], (-1, -1))

def merge_net_conns(bound_orig_names, name_bounds, ordered_conns):
  replace_nets = {}
  for part_name in ordered_conns:
    orig_part_name = bound_orig_names[name_bounds[part_name]]
    if 'N' not in part_name or '-intersection' in orig_part_name: continue
    if part_name not in replace_nets:
      replace_nets[part_name] = part_name
    for conn in ordered_conns[part_name]:
      if conn[0] not in name_bounds:
        continue
      conn_orig_part_name = bound_orig_names[name_bounds[conn[0]]]
      if 'N' not in conn[0] or conn[0] in replace_nets or '-intersection' in conn_orig_part_name: continue
      replace_nets[conn[0]] = replace_nets[part_name]
      print(f'merging {conn[0]} into {replace_nets[conn[0]]}')
  for part_name in ordered_conns:
    if 'N' in part_name: continue
    for i, conn in enumerate(ordered_conns[part_name]):
      if conn[0] in replace_nets:
        ordered_conns[part_name][i] = (replace_nets[conn[0]][1:], conn[1], conn[2])
      if 'VDD' in conn[0]:
        ordered_conns[part_name][i] = ('VDD', conn[1], conn[2])
      if 'G' in conn[0]:
        ordered_conns[part_name][i] = ('0', conn[1], conn[2])

def ordered_conns_to_spice(page_id, ordered_conns, name_bounds, bound_orig_names):
  netlist_lines, cpnt_marks, conn_marks = [], {}, {}
  subskt_count = 0
  used_nmos, used_pmos = False, False
  for part_name in ordered_conns:
    orig_part_name = bound_orig_names[name_bounds[part_name]]
    if 'N' in part_name or 'G' in part_name or 'VDD' in part_name: continue
    if 'I' in part_name and 'arrow' not in orig_part_name: continue
    cpnt_marks[part_name] = [name_bounds[part_name]]
    line = part_name
    for i, conn in enumerate(ordered_conns[part_name]):
      if conn[0][0] == 'N':
        conn = (conn[0][1:], conn[1], conn[2])
      if conn[0][0] == 'M' and i > 2: break # skip B connections for mos
      if conn[0] not in conn_marks:
        conn_marks[conn[0]] = []
      r, c = conn[1]
      conn_marks[conn[0]].append((r - 5, c - 5, r + 5, c + 5))
      line += f' {conn[0]}'
    if 'mos' in orig_part_name:
      s_conn = line.split(' ')[-1]
      part_type = orig_part_name.split('_')[0].split('-')[0].upper()
      if part_type == 'NMOS': used_nmos = True
      if part_type == 'PMOS': used_pmos = True
      line += f' {s_conn} {part_type} W=1u L=1u'
    if 'pn' in orig_part_name:
      s_conn = line.split(' ')[-1]
      part_type = orig_part_name.split('_')[0].split('-')[0].upper()
      line += f' {s_conn} {part_type}'
    elif 'R' in part_name:
      line += ' 1k'
    elif 'I' in part_name:
      line += ' DC 1mA'
    elif 'V' in part_name:
      line += ' 5V'
    elif 'C' in part_name:
      line += ' 1nF'
    elif 'L' in part_name:
      line += ' 1uH'
    elif 'X' in part_name:
      subskt_count += 1
      line += f' SUBSKT_{subskt_count}'
    netlist_lines.append(line)
  joint_lines = '\n'.join(netlist_lines)
  subskt_lines = '\n'.join([f'.SUBSKT_{i} PORT1 PORT2 PORT3 PORT4\n_\n.ENDS\n*' for i in range(subskt_count)])
  nmos_line = '\n.MODEL NMOS NMOS (LEVEL=1 VTO=1 KP=1.0e-4 LAMBDA=0.02)' if used_nmos else ''
  pmos_line = '\n.MODEL PMOS PMOS (LEVEL=1 VTO=1 KP=1.0e-4 LAMBDA=0.02)' if used_pmos else ''
  netlist = f'''*SPICE Netlist for circuit {page_id}
{joint_lines}{nmos_line}{pmos_line}
{subskt_lines}
.OP
.END
'''
  return netlist, cpnt_marks, conn_marks

def gen_spice_netlist(page_id, page_bin, bounds):
  part_counts, bound_names, name_bounds, bound_orig_names = reformat_names(bounds)
  conns = get_conns(part_counts, bound_names, name_bounds, bound_orig_names)
  ordered_conns = reorder_conns(page_bin, part_counts, bound_orig_names, name_bounds, conns)
  reroute_conns(bound_orig_names, name_bounds, ordered_conns)
  disconnect_component_conns(part_counts, ordered_conns)
  merge_net_conns(bound_orig_names, name_bounds, ordered_conns)
  return ordered_conns_to_spice(page_id, ordered_conns, name_bounds, bound_orig_names)

"""# Manual Labeling"""

f = open(f'{root_path}/test.JSON')
data = json.load(f)
for i in data['rectangle']:
  print(i)
  crop_part(f'{page_bin_path}/0.npy', i["y1"], i["x1"], i["y2"], i["x2"], save_fn=i["label"])

"""# Run"""

export_dir = f'{root_path}/export_20240510'

# for page_id in range(0, 894):
for page_id in range(0, 1):
  try:
    print(f'page {page_id}')
    part_match_all(f'{page_bin_path}/{page_id}.npy', visualize=False)
    page_data = json.load(codecs.open(f'{page_data_path}/{page_id}.json', 'r', encoding='utf-8'))
    page_bin = np.load(f'{page_bin_path}/{page_id}.npy')
    cpnt_detect_img = mark_bounds(page_bin, page_data)
    netlist, cpnt_marks, conn_marks = gen_spice_netlist(page_id, page_bin, page_data)
    net_detect_img = mark_bounds(mark_bounds(page_bin, cpnt_marks, visualize=False, dist=(50, 20)), conn_marks, color=(255, 0, 0), dist=(25, 10), solid=True)

    os.makedirs(f'{export_dir}/{page_id}', exist_ok=True)
    bin2img(page_bin).save(f'{export_dir}/{page_id}/{page_id}.jpg')
    cpnt_detect_img.save(f'{export_dir}/{page_id}/{page_id}_cpnt.jpg')
    net_detect_img.save(f'{export_dir}/{page_id}/{page_id}_net.jpg')
    #Update json instead of replacing
    print(page_data)
    for key,value in page_data.items():
      if value != []:
        for i in value:
          i.append([""])
    
    prevjson = json.load(codecs.open(f'{export_dir}/{page_id}/{page_id}_bbox.json', 'r', encoding='utf-8'))
    for key,value in prevjson.items():
      if key in page_data and isinstance(page_data[key],list):
        page_data[key].extend(value)
      else:
        page_data[key] = value
    json.dump(page_data, codecs.open(f'{export_dir}/{page_id}/{page_id}_bbox.json', 'w', encoding='utf-8'), indent=2)
    write_strings(f'{export_dir}/{page_id}/{page_id}.cir', [netlist])
    print(netlist)
  except Exception as e:
    print(e)
